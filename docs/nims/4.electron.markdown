---
layout: default
title: 4. Electron
parent: NIMS 👩‍💻 
nav_order: 4
---

<details open markdown="block">
  <summary>
    Table of contents
  </summary>
  {: .text-delta }
- TOC
{:toc}
</details>

---
_[electron 공식홈페이지]("https://www.electronjs.org/")를 참고하여 작성한 페이지입니다._
## 0. Electron Introduction
### 1. what is electron? 
![web_application27.png](https://github.com/Sujinkim-625/Sujinkim-625.github.io/blob/main/docs/nims/image/web_application27.png?raw=true) 


Electron은 JavaScript, HTML, CSS를 사용하여 데스크탑 어플리케이션을 구축하기 위한 프레임워크.    
별도의 네이티브 개발 경험없이 Chromium(Frontend)과 Node.js(Backend)를 이진파일에 포함시켜(하나의 런타임으로 통합하여 구성)    
Electron은 하나의 JavaScript 코드베이스를 유지하면서 Windows, macOS, Linux에서 작동하는 크로스 플랫폼 앱을 만들 수 있게 해준다.
{: .fs-3 }   


### 2.process model

chromium의 다중 아키텍쳐를 물려받아 main process와 render process 두 가지 유형의 프로세스 제공 
{: .fs-3 }  

![web_application28.png](https://github.com/Sujinkim-625/Sujinkim-625.github.io/blob/main/docs/nims/image/web_application28.png?raw=true)   

main process   
Node.js 기반으로 Node.js에서 사용되는 모든 모듈(~~*all of Node.js APIs*~~) 사용 가능, back-end의 영역. 어플리케이션의 진입점 역할(*~~the application's entry point~~*). electron application 당 1개만 존재할 수 있음.
{: .fs-3 }   

*  window management   
create and manage application windows with the [BrowserWindow](https://www.electronjs.org/docs/latest/api/browser-window) module  
*~~화면에 창을 띄우고 끄는 기본적인 동작부터 자동 업데이트, 메뉴 커스텀 등의 다양한 기능을 지원한다. 또한 Renderer Process와의 통신을 통해 다양한 화면을 창에 띄우게 된다~~*  
{: .fs-3 }   

* Application lifecycle (어플리케이션의 생명주기 제어)
{: .fs-3 }   

render process  
HTML, CSS, JavaScript로 이루어지는, front-end의 영역. 콘텐츠를 렌더링하는 역할.   
chromium의 멀티 프로세스 아키텍처가 그대로 이용, 일렉트론 안에서 보이는 각각의 웹페이지는 자신의 process 안에서 동작. electron application 당 개수 제한 없이 여러 개가 존재할 수 있음.   
{: .fs-3 }   

<details>
<summary>
메인 프로세스와 렌더러 프로세스의 차이점   
</summary>
<div markdown="1">

[원문보기]("https://tinydew4.gitbooks.io/electron-ko/content/tutorial/quick-start.html")

메인 프로세스는 BrowserWindow Class를 사용하여 새로운 창을 만들 수 있습니다.  BrowserWindow 인스턴스는 따로 분리된 프로세스에서 렌더링 되며 이 프로세스를 렌더러 프로세스라고 합니다. BrowserWindow 인스턴스가 소멸할 때 그 창의 렌더러 프로세스도 같이 소멸합니다.
{: .fs-3 }   
    
메인 프로세스는 모든 웹 페이지와 렌더러 프로세스를 관리하며 렌더러 프로세스는 각각의 프로세스에 고립되며 웹 페이지의 작동에만 영향을 끼칩니다.
{: .fs-3 }   
    
웹 페이지 내에선 기본적으로 네이티브 GUI와 관련된 API를 호출할 수 없도록 설계 되어 있습니다. 왜냐하면 웹 페이지 내에서 네이티브 GUI 리소스를 관리하는 것은 보안에 취약하고 리소스를 누수시킬 수 있기 때문입니다. 꼭 웹 페이지 내에서 API를 사용해야 한다면 메인 프로세스에서 그 작업을 처리할 수 있도록 메인 프로세스와 통신을 해야 합니다.
{: .fs-3 }   
    
Electron에는 메인 프로세스와 렌더러 프로세스 사이에 통신을 할 수 있도록 [ipcRenderer](https://tinydew4.gitbooks.io/electron-ko/content/api/ipc-renderer.html)와 [ipcMain](https://tinydew4.gitbooks.io/electron-ko/content/api/ipc-main.html) 모듈을 제공하고 있습니다. 또는 [remote](https://tinydew4.gitbooks.io/electron-ko/content/api/remote.html) 모듈을 사용하여 RPC 스타일로 통신할 수도 있습니다
{: .fs-3 }   

</div>
</details>


### 3.Inter-Process Communication (IPC)
[tutorial IPC](https://www.electronjs.org/docs/latest/tutorial/ipc)  
![web_application29.png](https://github.com/Sujinkim-625/Sujinkim-625.github.io/blob/main/docs/nims/image/web_application29.png?raw=true)   
Electron의 프로세스 모델에서 메인프로세스와 렌더러 프로세스가 서로 다른 역할을 가지고 있기 때문에 메인 프로세스와 렌더러 프로세스 사이에 통신을 할 수 있도록 ipcRenderer와 ipcMain 모듈을 제공
[원문보기](https://velog.io/@qortmdalsdl/%EC%9D%BC%EB%A0%89%ED%8A%B8%EB%A1%A0Electron-%EC%A0%95%EB%A6%AC)
{: .fs-3 }   

[참고자료]   
[Electron 개요 및 구조](https://velog.io/@yijaee/Electron-%EA%B0%9C%EC%9A%94-%EB%B0%8F-%EA%B5%AC%EC%A1%B0)   
[일렉트론(Electron) 정리](https://velog.io/@qortmdalsdl/%EC%9D%BC%EB%A0%89%ED%8A%B8%EB%A1%A0Electron-%EC%A0%95%EB%A6%AC)
{: .fs-3 }   

---
## 1. Prerequisites
Electron app을 개발하기 위해서는 (LTS 이상의)Node.js와 npm package manager가 설치되어야한다.  
{: .fs-3 }   

macOS를 기준으로, homebrew를 설치하고 homebrew를 이용하여 nvm을 설치, 그리고 nvm을 이용하여 node를 설치하면 된다. 자세한 설치 방법은 [참고블로그](https://memostack.tistory.com/274)에 설명이 잘 되어있다. npm은 node를 설치하면 설치가 될 것이다.   
{: .fs-3 }   

✔︎ 설치 및 버전 확인하기
{: .fs-3 }   
```
node -v
npm -w
```
<details>
<summary>
실행화면     
</summary>
<div markdown="1">
![web_application31.png](https://github.com/Sujinkim-625/Sujinkim-625.github.io/blob/main/docs/nims/image/web_application31.png?raw=true)  
</div>
</details>

[참고자료]   
[Elctron 시작하기](https://oraange.tistory.com/30)
{: .fs-3 }   

---
## 2. Building your First App - Setting up your project
### Initializing your npm project

> Start by creating a folder and initializing an npm package within it with npm init.  
{: .fs-3 }   


```
mkdir my-electron-app
cd my-electron-app
npm init
```
<details>
<summary>
  실행화면     
</summary>
<div markdown="1">

![web_application32.png](https://github.com/Sujinkim-625/Sujinkim-625.github.io/blob/main/docs/nims/image/web_application32.png?raw=true)    
This command will prompt you to configure some fields in your package.json.   
{: .fs-3 }   


![web_application33.png](https://github.com/Sujinkim-625/Sujinkim-625.github.io/blob/main/docs/nims/image/web_application33.png?raw=true)  
package.json이 생성된 것을 볼 수 있다. (”main”: index.js → main.js로 바꿔준다.)   
{: .fs-3 }   

AS-IS   
{: .fs-3 }   

![web_application34.png](https://github.com/Sujinkim-625/Sujinkim-625.github.io/blob/main/docs/nims/image/web_application34.png?raw=true) 

TO-BE   
{: .fs-3 }   

![web_application35.png](https://github.com/Sujinkim-625/Sujinkim-625.github.io/blob/main/docs/nims/image/web_application35.png?raw=true) 

</div>
</details>
<br>
> install electron —save-dev       
{: .fs-3 }   

You should also now have a node_modules folder containing the Electron executable, as well as a `package-lock.json` lockfile that specifies the exact dependency versions to install.   
{: .fs-3 }   

```
npm install electron —save-dev
```

<details>
<summary>
실행화면     
</summary>
<div markdown="1">

![web_application36.png](https://github.com/Sujinkim-625/Sujinkim-625.github.io/blob/main/docs/nims/image/web_application36.png?raw=true) 

node_modules, `package-lock.json`, `package.json` 코드에 devDependencies가 추가되었다!   
{: .fs-3 }   

![web_application37.png](https://github.com/Sujinkim-625/Sujinkim-625.github.io/blob/main/docs/nims/image/web_application37.png?raw=true) 
</div>
</details>

### Running an Electron app

`package.json` 파일의 메인 스크립트는 앱이 시작될 때 실행되는 중심적인 코드를 담고 있으며, 이 코드는 주로 메인 프로세스에서 앱의 핵심적인 기능을 담당한다. 이 프로세스는 Node.js를 기반으로 동작하며, 앱의 전반적인 동작을 조정하고 관리하는 역할을 수행한다.   
{: .fs-3 }   

<details>
<summary>
메인 프로세스 진입점이 올바르게 구성되었는지 확인하기(생략가능)
</summary>
<div markdown="1">
Electron의 메인 프로세스는 일반적인 Node.js 환경과 유사하게 동작한다. 따라서 electron 명령을 사용하여 메인 프로세스 스크립트를 실행하면, Node.js에서 사용되는 모듈이나 기능들을 Electron 메인 프로세스에서도 활용할 수 있다.   
{: .fs-3 }   

```
//main.js
// Create a main.js file in the root folder of your project
console.log('Hello from Electron')
```

```
//package.json
//script 안에 start 코드를 추가.
"scripts": {
    "start": "electron .",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
```
개발 모드에서 Electron을 실행하려면 터미널에서 다음과 같은 명령어를 사용   
{: .fs-3 }   

```
npm run start
```
<details>
<summary>
실행화면     
</summary>
<div markdown="1">

![web_application38.png](https://github.com/Sujinkim-625/Sujinkim-625.github.io/blob/main/docs/nims/image/web_application38.png?raw=true) 
![web_application39.png](https://github.com/Sujinkim-625/Sujinkim-625.github.io/blob/main/docs/nims/image/web_application39.png?raw=true) 
![web_application40.png](https://github.com/Sujinkim-625/Sujinkim-625.github.io/blob/main/docs/nims/image/web_application40.png?raw=true) 
</div>
</details>

</div>
</details>

### Loading a web page into a BrowserWindow

Electron에서 각 창은 로컬 HTML 파일 또는 원격 웹 주소에서 로드될 수 있는 웹 페이지를 표시한다. 프로젝트의 루트 폴더에 `index.html` 파일을 만들어 기본 웹 페이지를 생성하자! 그럼, Electron BrowserWindow에 로드할 수 있다.   
{: .fs-3 }   

<details>
<summary>
코드 보기     
</summary>
<div markdown="1">

```
//index.html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <!-- https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP -->
    <meta
      http-equiv="Content-Security-Policy"
      content="default-src 'self'; script-src 'self'"
    />
    <meta
      http-equiv="X-Content-Security-Policy"
      content="default-src 'self'; script-src 'self'"
    />
    <title>Hello from Electron renderer!</title>
  </head>
  <body>
    <h1>Hello from Electron renderer!</h1>
    <p>👋</p>
  </body>
</html>
```
</div>
</details>

<details>
<summary>
실행화면     
</summary>
<div markdown="1">

![web_application41.png](https://github.com/Sujinkim-625/Sujinkim-625.github.io/blob/main/docs/nims/image/web_application41.png?raw=true) 
</div>
</details>

main.js 수정하기   

<details>
<summary>
코드 보기     
</summary>
<div markdown="1">

```
//main.js
const { app, BrowserWindow } = require('electron')

const createWindow = () => {
  const win = new BrowserWindow({
    width: 800,
    height: 600
  })

  win.loadFile('index.html')
}

app.whenReady().then(() => {
  createWindow()
})
```

</div>
</details>

<details>
<summary>
코드 설명     
</summary>
<div markdown="1">
Importing two Electron modules with CommonJS module syntax
{: .fs-3 }   

- *app: 전반적인 애플리케이션 이벤트 라이프사이클을 제어*
- *BrowserWindow: 애플리케이션 창의 생성과 관리를 담당*
{: .fs-3 }   

```
const { app, BrowserWindow } = require('electron')
```

Writing a reusable function to instantiate windows (재사용 가능한 함수를 작성하여 창을 생성)
{: .fs-3 }   

- *createWindow() 함수는 새로운 BrowserWindow 인스턴스를 생성하고, 해당 창의 구성을 설정하며(width, height, webPreferences 등), index.html 파일을 창에 로드*
{: .fs-3 }   

```
const createWindow = () => {
  const win = new BrowserWindow({
    width: 800,
    height: 600
  })

  win.loadFile('index.html')
}
```

Calling your function when the app is ready
{: .fs-3 }   

- *Electron에서 BrowserWindow은 app 모듈의 ready 이벤트가 발생한 후에만 생성할 수 있다. app.whenReady() API를 사용하고 해당 프로미스가 이행되면 createWindow()을 호출함으로써 이 이벤트를 기다릴 수 있다.*
- *애플리케이션이 초기화되고 필요한 설정이 완료된 후에 창을 생성하도록 보장*
{: .fs-3 }   

```
app.whenReady().then(() => {
  createWindow()
})
```

이제, Electron 애플리케이션의 시작 명령을 실행하면 성공적으로 웹 페이지가 표시되는 창이 열릴 것이다!
{: .fs-3 }   

</div>
</details>

<details>
<summary>
실행화면     
</summary>
<div markdown="1">

![web_application42.png](https://github.com/Sujinkim-625/Sujinkim-625.github.io/blob/main/docs/nims/image/web_application42.png?raw=true)

![web_application43.png](https://github.com/Sujinkim-625/Sujinkim-625.github.io/blob/main/docs/nims/image/web_application43.png?raw=true) 
</div>
</details>

### Managing your app's window lifecycle

*[Windows 및 Linux] 일반적으로 모든 창을 닫으면 애플리케이션이 완전히 종료된다. Electron 앱에서 이 패턴을 구현하려면 app 모듈의 **`window-all-closed`** 이벤트를 감지하고, 사용자가 macOS에서 작업 중이 아닌 경우 app.quit()을 호출하여 앱을 종료하도록 한다.*   
{: .fs-3 }   

```
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') app.quit()
})
```
*[macOS] macOS에서는 창을 닫아도 앱이 완전히 종료되지 않고, macOS 앱은 일반적으로 창이 열려 있지 않아도 계속 실행된다. 창이 없을 때 앱을 활성화하면 새 창이 열리도록 해야한다. 창이 준비되기 전에는 창을 만들 수 없으므로, 앱이 초기화된 후에만 activate 이벤트를 감지하도록 해야한다. 기존의 whenReady() 콜백 내에서만 activate 이벤트를 수신하도록 한다.*
{: .fs-3 }   

```
app.whenReady().then(() => {
  createWindow()

  app.on('activate', () => {
    if (BrowserWindow.getAllWindows().length === 0) createWindow()
  })
})
```
---
## 3. Using Preload Scripts
### What is a preload script?

*Electron의 메인 프로세스는 전체 운영 체제에 액세스할 수 있는 Node.js 환경이다. Electron 모듈뿐만 아니라 npm을 통해 설치한 패키지나 Node.js의 기본 내장 모듈에도 액세스할 수 있다. 반면에, 보안상의 이유로 렌더러 프로세스는 기본적으로 Node.js를 실행하지 않고 웹 페이지를 실행한다.*
{: .fs-3 }   

*Electron의 다른 프로세스 유형을 함께 연결하려면 preload라고 불리는 특수한 스크립트를 사용해야 한다.*
{: .fs-3 }   

### Augmenting the renderer with a preload script
`preload.js`   
*preload script는 렌더러에서 웹 페이지가 로드되기 전에 주입되며, 이는 크롬 익스텐션의 컨텐트 스크립트와 유사하다. 특권 있는 액세스가 필요한 렌더러에 기능을 추가하려면 contextBridge API를 사용하여 전역 객체를 정의할 수 있다.*
{: .fs-3 }   

<details>
<summary>
코드보기     
</summary>
<div markdown="1">

```
//preload.js
const { contextBridge } = require('electron')

contextBridge.exposeInMainWorld('versions', {
  node: () => process.versions.node,
  chrome: () => process.versions.chrome,
  electron: () => process.versions.electron
  // we can also expose variables, not just functions
})
```
</div>
</details>

<details>
<summary>
실행화면     
</summary>
<div markdown="1">

![web_application44.png](https://github.com/Sujinkim-625/Sujinkim-625.github.io/blob/main/docs/nims/image/web_application44.png?raw=true) 

</div>
</details>

`main.js`

*이 스크립트를 렌더러 프로세스에 연결하려면 BrowserWindow 생성자의 webPreferences.preload 옵션에 해당 스크립트의 경로를 전달하면 된다.*
{: .fs-3 }   

<details>
<summary>
코드보기     
</summary>
<div markdown="1">

```
//main.js
const { app, BrowserWindow } = require('electron')
const path = require('node:path')

const createWindow = () => {
  const win = new BrowserWindow({
    width: 800,
    height: 600,
    webPreferences: {
      preload: path.join(__dirname, 'preload.js')
    }
  })

  win.loadFile('index.html')
}

app.whenReady().then(() => {
  createWindow()
})
```
</div>
</details>
<details>
<summary>
실행화면     
</summary>
<div markdown="1">

![web_application45.png](https://github.com/Sujinkim-625/Sujinkim-625.github.io/blob/main/docs/nims/image/web_application45.png?raw=true) 
![web_application46.png](https://github.com/Sujinkim-625/Sujinkim-625.github.io/blob/main/docs/nims/image/web_application46.png?raw=true) 
</div>
</details>


`renderer.js`

*현재 시점에서 렌더러는 versions 전역 변수에 액세스할 수 있다. 이 정보를 창에 표시해 보겠다. 이 변수는 **window.versions** 또는 간단히 **versions**를 통해 액세스할 수 있습니다. **info**라는 id 속성을 가진 HTML 요소의 텍스트를 변경하는 데는 document.getElementById DOM API를 사용하겠다.*
{: .fs-3 }   

<details>
<summary>
코드보기     
</summary>
<div markdown="1">

```
//renderer.js
const information = document.getElementById('info')
information.innerText = `This app is using Chrome (v${versions.chrome()}), Node.js (v${versions.node()}), and Electron (v${versions.electron()})`
```
</div>
</details>

<details>
<summary>
실행화면     
</summary>
<div markdown="1">

![web_application47.png](https://github.com/Sujinkim-625/Sujinkim-625.github.io/blob/main/docs/nims/image/web_application47.png?raw=true) 
</div>
</details>

`index.html`

*index.html을 수정하여 id 속성이 'info'인 새로운 요소를 추가하고, renderer.js 스크립트를 연결*
{: .fs-3 }   

<details>
<summary>
코드보기     
</summary>
<div markdown="1">
```

#index.html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta
      http-equiv="Content-Security-Policy"
      content="default-src 'self'; script-src 'self'"
    />
    <meta
      http-equiv="X-Content-Security-Policy"
      content="default-src 'self'; script-src 'self'"
    />
    <title>Hello from Electron renderer!</title>
  </head>
  <body>
    <h1>Hello from Electron renderer!</h1>
    <p>👋</p>
    <p id="info"></p>
  </body>
  <script src="./renderer.js"></script>
</html>
```
</div>
</details>

<details>
<summary>
실행화면     
</summary>
<div markdown="1">

![web_application48.png](https://github.com/Sujinkim-625/Sujinkim-625.github.io/blob/main/docs/nims/image/web_application48.png?raw=true) 
</div>
</details>

<br>
실행결과
{: .fs-3 }   

![web_application49.png](https://github.com/Sujinkim-625/Sujinkim-625.github.io/blob/main/docs/nims/image/web_application49.png?raw=true) 

프로젝트 트리
{: .fs-3 }   
![web_application50.png](https://github.com/Sujinkim-625/Sujinkim-625.github.io/blob/main/docs/nims/image/web_application50.png?raw=true) 

---

## 4. Packaging Your Application - Using Electron Forge
Electron은 핵심 모듈에 패키징 및 배포 도구가 내장되어 있지 않다. 따라서 개발 모드에서 작동하는 Electron 앱을 배포할 수 있는 패키지로 만들려면 추가 도구를 사용해야한다. 이러한 패키지를 배포 가능한 앱이라고도 한다. 배포 가능한 앱은 설치 프로그램(예: Windows의 MSI) 또는 휴대용 실행 파일(예: macOS의 .app)일 수 있다.
{: .fs-3 }   

Electron Forge는 Electron 앱의 패키징 및 배포를 처리하는 올인원 도구이다. 이 도구는 핵심적으로 많은 기존 Electron 도구들 (예: electron-packager, @electron/osx-sign, electron-winstaller 등)을 단일 인터페이스로 통합하여 이들을 모두 함께 사용할 필요가 없도록 만들어 준다.
{: .fs-3 }   

### Importing your project into Forge
```
npm install --save-dev @electron-forge/cli
npx electron-forge import
```
<details>
<summary>
실행화면     
</summary>
<div markdown="1">

![web_application51.png](https://github.com/Sujinkim-625/Sujinkim-625.github.io/blob/main/docs/nims/image/web_application51.png?raw=true) 

![web_application52.png](https://github.com/Sujinkim-625/Sujinkim-625.github.io/blob/main/docs/nims/image/web_application52.png?raw=true) 

package.json에 forge 관련 코드가 추가된다.
{: .fs-3 }   

![web_application53.png](https://github.com/Sujinkim-625/Sujinkim-625.github.io/blob/main/docs/nims/image/web_application53.png?raw=true) 


</div>
</details>

### Creating a distributable
```
npm run make
```
<details>
<summary>
make command 설명
</summary>
<div markdown="1">

1. electron-forge package 실행:   
- 먼저, 내부에서 electron-forge package 명령을 실행.   
- 이 명령은 Electron 이진 파일과 함께 앱 코드를 번들링. 번들링된 코드는 특정 폴더에 생성됨.
- 즉, Electron 앱 코드와 Electron 바이너리가 함께 패키징되어 실행 가능한 형태로 만들어진다
2. Distributable 생성:
- 그런 다음, 이 패키지된 앱 폴더를 사용하여 각 설정된 메이커(Maker)에 대해 별도의 배포용 파일을 생성.
- 각 메이커는 특정한 배포 형식 또는 플랫폼을 나타냅니다. 예를 들어, @electron-forge/maker-deb은 Debian 운영 체제용 패키지를 생성하고, @electron-forge/maker-squirrel은 Windows용 설치 프로그램을 생성.
- 이렇게 생성된 배포용 파일은 사용자에게 제공되어 설치하거나 실행할 수 있는 형태로 제공.
{: .fs-3 }   

</div>
</details>

<details>
<summary>
실행화면     
</summary>
<div markdown="1">

![web_application54.png](https://github.com/Sujinkim-625/Sujinkim-625.github.io/blob/main/docs/nims/image/web_application54.png?raw=true) 

out folder 안에 파일이 생성됨.
{: .fs-3 }   

![web_application55.png](https://github.com/Sujinkim-625/Sujinkim-625.github.io/blob/main/docs/nims/image/web_application55.png?raw=true) 
</div>
</details>
<br>
코드트리
{: .fs-3 }   

![web_application56.png](https://github.com/Sujinkim-625/Sujinkim-625.github.io/blob/main/docs/nims/image/web_application56.png?raw=true) 

## 5. Publishing and Updating
### Using update.electronjs.org
*requirements*
- Your app runs on macOS or Windows
- Your app has a public GitHub repository
- Builds are published to [GitHub releases](https://docs.github.com/en/repositories/releasing-projects-on-github/managing-releases-in-a-repository)
- Builds are [code signed](https://www.electronjs.org/docs/latest/tutorial/code-signing)
{: .fs-3 }   

### Publishing a GitHub release
#### a. Generating a personal access token
[create a new personal access token(PAT)](https://github.com/settings/tokens/new) *with the public_repo scope, which gives write access to your public repositories (**repo 체크**)*   
*PAT는 저장해둬야 함.*
{: .fs-3 }   

<details>
<summary>
create a new PAT     
</summary>
<div markdown="1">

![web_application57.png](https://github.com/Sujinkim-625/Sujinkim-625.github.io/blob/main/docs/nims/image/web_application57.png?raw=true)
</div>
</details>
<br>
#### b. Setting up the GitHub Publisher
##### Installing the module
```
npm install --save-dev @electron-forge/publisher-github
```
<details>
<summary>
실행화면     
</summary>
<div markdown="1">

![web_application58.png](https://github.com/Sujinkim-625/Sujinkim-625.github.io/blob/main/docs/nims/image/web_application58.png?raw=true)
</div>
</details>

##### Configuring the publisher in Forge
```
//forge.config.js
module.exports = {
  publishers: [
    {
      name: '@electron-forge/publisher-github',
      config: {
        repository: {
          owner: 'github-user-name',
          name: 'github-repo-name'
        },
        prerelease: false,
        draft: true
      }
    }
  ]
}
```
<details>
<summary>
코드 화면     
</summary>
<div markdown="1">

![web_application59.png](https://github.com/Sujinkim-625/Sujinkim-625.github.io/blob/main/docs/nims/image/web_application59.png?raw=true)
</div>
</details>

### Running the publish command
#### package.json
```
//package.json
//...
  "scripts": {
    "start": "electron-forge start",
    "package": "electron-forge package",
    "make": "electron-forge make",
    "publish": "electron-forge publish"
  },
  //...
```

<details>
<summary>
코드화면     
</summary>
<div markdown="1">

![web_application60.png](https://github.com/Sujinkim-625/Sujinkim-625.github.io/blob/main/docs/nims/image/web_application60.png?raw=true)
</div>
</details>

#### publish
```
npm run publish
```
<details>
<summary>
실행화면     
</summary>
<div markdown="1">

![web_application61.png](https://github.com/Sujinkim-625/Sujinkim-625.github.io/blob/main/docs/nims/image/web_application61.png?raw=true)
</div>
</details>

#### github release(draft) 
![web_application62.png](https://github.com/Sujinkim-625/Sujinkim-625.github.io/blob/main/docs/nims/image/web_application62.png?raw=true)

#### publish release
![web_application63.png](https://github.com/Sujinkim-625/Sujinkim-625.github.io/blob/main/docs/nims/image/web_application63.png?raw=true)

#### release done!
![web_application64.png](https://github.com/Sujinkim-625/Sujinkim-625.github.io/blob/main/docs/nims/image/web_application64.png?raw=true)
